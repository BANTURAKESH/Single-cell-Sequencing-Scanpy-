# -*- coding: utf-8 -*-
"""Scanpy.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1VB4bvXOH5hDEaexrod6hYj63hVP5ly-s
"""

!pip install scanpy umap-learn anndata numpy scipy pandas matplotlib scrublet seaborn python-igraph louvain leidenalg

!pip install scanpy anndata matplotlib seaborn scikit-learn

import scanpy as sc
import anndata as ann
import scipy as sp
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from matplotlib import rcParams
from matplotlib import colors

# Global settings
sc.settings.verbosity = 3  # Verbosity: errors (0), warnings (1), info (2), hints (3)
sc.logging.print_header()
sc.settings.set_figure_params(dpi=100, facecolor='white')
sc.set_figure_params(scanpy=True)

sns.set_context(context='poster')

"""Raw Data → AnnData object → Quality Control → Normalization → HVG → PCA → Clustering → UMAP/tSNE → Marker Genes

1. Load the Data
"""

adata = sc.read_h5ad('/content/data/pbmc3k_raw.h5ad')
print(adata)

adata.shape

print('Total number of observations: {:d}'.format(adata.n_obs))

# Variables metadata (gene-level, e.g., gene names, HVGs)
adata.var_names

#Observations metadata (cell-level, e.g., clusters, QC)
adata.obs

adata.var_names_make_unique()

adata.obs_names

"""QUALITY CONTROL (QC)"""

# Annotate mitochondrial genes
adata.var['mt'] = adata.var_names.str.upper().str.startswith('MT-')

# Compute QC metrics
sc.pp.calculate_qc_metrics(adata, qc_vars=['mt'], percent_top=None, log1p=False, inplace=True)

# Plot QC metrics
sc.pl.violin(adata, ['n_genes_by_counts', 'total_counts', 'pct_counts_mt'], jitter=0.4, multi_panel=True)
sc.pl.scatter(adata, x='total_counts', y='pct_counts_mt')
sc.pl.scatter(adata, x='total_counts', y='n_genes_by_counts')

# Filter cells
adata = adata[adata.obs.n_genes_by_counts < 2500, :]
adata = adata[adata.obs.pct_counts_mt < 5, :]
adata = adata[adata.obs.total_counts < 20000, :]

# Filter genes
sc.pp.filter_genes(adata, min_cells=3)

# Checking for the Highly expressed genes(top-20)
sc.pl.highest_expr_genes(adata, n_top=20, )

"""NORMALIZATION & LOG TRANSFORMATION"""

# Normalize per cell
sc.pp.normalize_total(adata, target_sum=1e4)

# Logarithmize
sc.pp.log1p(adata)

# Store raw (for future use like marker identification)
adata.raw = adata

"""IDENTIFY HIGHLY VARIABLE GENES (HVGs)"""

sc.pp.highly_variable_genes(adata, min_mean=0.0125, max_mean=3, min_disp=0.5)

# Visualize HVGs
sc.pl.highly_variable_genes(adata)

# Subset to HVGs
adata = adata[:, adata.var.highly_variable]

adata





"""SCALE & DIMENSION REDUCTION"""

# Scale data
sc.pp.scale(adata, max_value=10)

# PCA
sc.tl.pca(adata, svd_solver='arpack')
sc.pl.pca_variance_ratio(adata, log=True)

"""NEIGHBORHOOD GRAPH & CLUSTERING"""

!pip install igraph leidenalg

# Compute neighborhood graph
sc.pp.neighbors(adata, n_neighbors=10, n_pcs=40)

# UMAP Embedding
sc.tl.umap(adata)

# Leiden clustering (robust alternative to Louvain)
sc.tl.leiden(adata, resolution=0.5)  # Tune resolution as needed

# Visualize UMAP
sc.pl.umap(adata, color=['leiden', 'n_genes_by_counts', 'pct_counts_mt'])

adata

"""MARKER GENE IDENTIFICATION"""

# Rank marker genes
sc.tl.rank_genes_groups(adata, groupby='leiden', method='wilcoxon')

# Visualize top genes per cluster
sc.pl.rank_genes_groups(adata, n_genes=20, sharey=False)

# Export marker genes to CSV
markers_df = sc.get.rank_genes_groups_df(adata, group=None)
markers_df.to_csv("marker_genes_all_clusters.csv", index=False)



